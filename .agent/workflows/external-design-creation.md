# 外部設計 作成ワークフロー

// turbo-all

---

## このワークフローの目的

PRDで定義された「世界」を**実装可能な粒度に落とし込む**ための外部設計を作成するプロセスを定義する。
PRDの各パーツが**摩擦ゼロで連動する**設計を目指し、部分最適ではなく全体最適を優先する。

> **PRDとの関係**: PRDは「何を・なぜ作るか」を定義する。外部設計は「どう組み合わせて動かすか」を定義する。

---

## 外部設計を作成するステップ

### ステップ 1: PRDの全文精読と構造把握

```
1. PRD_requirements.md を全行読み込む
2. ユーザー体験フロー図（mermaid）の全ノード・全矢印を書き出す
3. 各AIロール（A-E）の入出力スキーマ・アルゴリズムをリストアップ
4. KPI・非機能要件・設計思想の核心をリストアップ
```

確認すべき観点:
- フロー図の1つ1つの矢印が「何のデータを渡すか」を把握する
- 各ロールの出力が次のロールの入力の**型**と一致するか

---

### ステップ 2: 既存コードベースの全体スキャン

```bash
ls -la src/ai/crews/
ls -la src/ai/prompts/
ls -la api/
ls -la supabase/migrations/
```

確認すべき観点:
- PRDで新規追加・修正・廃止が必要なファイルの特定
- 現在のDBスキーマとPRDで要求されるスキーマの差分

---

### ステップ 3: 外部設計ドキュメントの作成（12セクション構成）

外部設計は以下の **12セクション構成** で作成する:

```
## 1. システム全体構成図（mermaid）
   - フロントエンド・API・AIパイプライン・DBの接続関係
   - 全ての矢印にデータ名を付ける

## 2. フェーズ別システム動作概要（表形式）
   - トリガー | 実行Role | DB書き込み | 応答時間上限

## 3. 画面設計（ASCII + 仕様テーブル）
   - 各画面のワイヤーフレーム
   - 各UI要素の「仕様」と「PRD根拠」を表形式で記載

## 4. API設計
   - 全エンドポイント: リクエスト/レスポンスのJSON
   - サーバー側処理フロー（擬似コード）
   - Phase不整合・エッジケースのガード条件

## 5. Role処理の詳細仕様
   - 各Roleのプロンプト入力テンプレート（system/user）
   - 出力スキーマ（JSON）
   - アルゴリズム（擬似コード）
   - 禁止語・推奨語リスト

## 6. DBスキーマ設計
   - 既存テーブル変更（ALTER TABLE文）
   - 新規テーブル（CREATE TABLE文）
   - ER図（mermaid）

## 7. セッション復元設計
   - 全フェーズの復元手順（擬似コード）

## 8. 仮説品質基準の設計反映
   - PRDの学術基準をプロンプトとバリデーションに落とし込む

## 9. KPI計測設計
   - 各KPIのデータソースと計測方法

## 10. 非機能要件の設計反映
    - タイムアウト値・リトライ回数・モデル設定

## 11. エラーハンドリング設計
    - エラー種別・発生箇所・HTTPステータス・UX対応

## 12. 既存実装との差分まとめ
    - 継続/修正/新規/廃止を表形式で一覧化
```

---

### ステップ 4: Role間データフロー摩擦チェック

外部設計の全文を書き終えたら、**以下の5ラウンドの検証を必ず実行する**:

#### Round 1: ユーザー体験フロー図との完全照合
- PRDフロー図の**全ノード**が外部設計のどこで実装されるかトレース
- **全矢印**のデータフィールドが外部設計に定義されているか確認
- フロー図にない暗黙の遷移（戻る・エラー・復元）が設計されているか

#### Round 2: Role間データフロー摩擦チェック
- Role A → E → B のデータ受け渡しで**欠損フィールド**がないか
- Role A → C → スライダーUI のデータ変換に欠損がないか
- 各Roleの**出力スキーマ**が次Roleの**入力と完全一致**するか

#### Round 3: DB ↔ API ↔ UI の整合性チェック
- DBカラムがAPI レスポンスフィールドと1:1で対応するか
- APIレスポンスがUI表示に**必要な全データ**を含むか
- DB書き込みタイミングが全て明記されているか

#### Round 4: エッジケース・境界条件チェック
- 閾値の丁度の値（MGU=60%, 80%）の挙動が明確か
- 空配列・null・0件の場合の挙動が定義されているか
- 否定・訂正時のフローが明確か
- セッション復元時の全フェーズが網羅されているか

#### Round 5: プロダクトバリュー整合性チェック
- PRD §0「エグゼクティブサマリー」の世界を実現できる設計か
- PRD §8「設計思想の核心」の原則に違反していないか
- KPIが計測可能な設計になっているか
- 学術理論が設計に反映されているか

---

### ステップ 5: PRDとの相互参照ルール

外部設計で定義するすべての要素は、**PRDの根拠セクション番号を明記**する:

| 外部設計の要素 | PRD参照方法 |
|--------------|-----------|
| 画面仕様テーブルの各行 | 「根拠（PRD参照）」カラムに §番号 |
| アルゴリズムの擬似コード | コメントに `// PRD §3.2 Role A「xxx」より` |
| DB制約 | コメントに対応するPRD要件 |
| エラーハンドリング | PRDの非機能要件 §番号 |

---

### ステップ 6: cognitive_filter の適用ルール

このプロジェクト固有の重要ルール:

| 分類 | 会話中の扱い | 最終レポートでの扱い |
|------|-----------|-----------------|
| **Why語** | Whyの核心として深掘り対象 | レポートの中心に据える |
| **What語** | 思考のヒントとして活用OK | レポートに含めてOK |
| **How語** | 思考のヒントとして活用OK | **レポートからは除外** |

> How/Whatは「なぜそれを行いたいのか」の思考のヒント。排除ではなく**分類**して最終出力で制御する。

---

### ステップ 7: 設計変更時の更新ルール

外部設計の一部を変更した場合、以下を**全て同時に更新**する:

1. §1 システム全体構成図（mermaidの矢印・ノード）
2. §4 該当APIの擬似コード
3. §5 該当Roleのプロンプト・スキーマ
4. §6 DBスキーマ（ALTER TABLE / ER図）
5. §7 セッション復元設計
6. §11 エラーハンドリング（新しいエラーケース）
7. §12 差分まとめ（廃止・新規）

**1つでも更新が漏れた場合、実装でのバトンリレーに支障をきたす。**

---

### ステップ 8: 用語の統一ルール

PRDワークフローの用語統一ルールを継承する。加えて外部設計固有の用語:

| 正式名称 | 説明 | 禁止する表記 |
|---------|------|------------|
| `core_keywords` | anchor から抽出した全キーワード（Why/What/How含む） | 「Whyキーワードのみ」 |
| `cognitive_filter.detected_how` | How語リスト（レポートで除外対象） | `detected_how_what` |
| `cognitive_filter.detected_what` | What語リスト（レポートに含めてOK） | — |
| `raw_planner_output` | Role A の完全な生JSON出力 | 「plannerの結果」 |
| `raw_manager_output` | Role E の完全な生JSON出力 | 「managerの結果」 |
| `upsert` | INSERT ON CONFLICT DO UPDATE | 「更新または追加」 |

---

## チェックリスト（外部設計提出前に必ず確認）

- [ ] PRDフロー図の全ノードが外部設計のどこで実装されるかトレース済みか
- [ ] 全Roleの出力スキーマが次Roleの入力と完全一致するか
- [ ] API擬似コードに全てのエッジケースガードがあるか
- [ ] DBスキーマ（ALTER TABLE + ER図）が一致しているか
- [ ] セッション復元が全フェーズをカバーしているか
- [ ] cognitive_filterの分類（How/What分離）が全箇所で一貫しているか
- [ ] 5ラウンド検証を全て実施し、発見した問題を全件修正したか
- [ ] PRDの学術理論が設計のどこに反映されているか明記されているか
