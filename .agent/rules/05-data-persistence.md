---
description: "データ永続化・DB設計ルール。保存→復元の完全性保証、関心の分離、DB保存独立性。DB関連コード変更時は必ず参照。"
alwaysApply: true
---

# データ永続化・DB設計ルール

## 1. 永続化の基本原則

### 「保存→完全消去→復元で同じ画面が出るか」テスト（必須）
- データ永続化に関わるコードを修正した場合、必ずブラウザの完全リフレッシュ（Cmd+Shift+R）テストを行うこと
- 保存した時点と復元後の画面が**ピクセル単位で同じ**であることを目視確認する
- コードパスが存在すること ≠ 正しく動くこと。E2Eの動作確認が必須

### データフロー全体を検証する
保存側のコードだけでなく、以下の**データフロー全体**を必ずトレースすること:
1. **生成**: データが作られる箇所（AI応答パース等）
2. **state反映**: メモリ上のstate変数への格納
3. **DB保存**: Supabaseテーブルへの書き込み（全フィールドが保存されているか）
4. **DB復元**: テーブルからの読み込み（全フィールドが読まれているか）
5. **UI描画**: 復元データからの画面再構築（正しいデータソースを参照しているか）

## 2. テーブル設計ルール

### UPSERTのテーブルは最新しか保持しない
`UPSERT (ON CONFLICT)` を使うテーブルは**最新の状態しか保持しない**。
時系列の履歴が必要なユースケースがある場合は:
- 別途スナップショットテーブルを設ける（例: `aspect_snapshots`）
- または、INSERTで全バージョンを保持するテーブル設計にする

### テーブル設計前にユースケースを確認する
テーブルを設計する前に、以下を確認すること:
- そのデータを「最新だけ見たい」のか「履歴を辿りたい」のか
- ブラウザ更新後にどの画面要素が復元される必要があるか
- 複数のUI要素が同じテーブルを参照しているが、異なるタイムスタンプのデータが必要ではないか

## 3. フォールバックロジックの設計ルール

### AI判定とフォールバックを混ぜない
ステータス判定にAI判定値とフォールバック（ヒューリスティック）の2系統がある場合:
- フォールバックは**最も安全な値**を返すこと（例: "thin" or "empty"）
- フォールバックで**上位ステータス（OK等）を返してはならない**
- OK/合格の判定は、**明示的なソース（AI判定、ユーザー確認等）からのみ**許可する

```javascript
// ❌ NG: フォールバックでOK判定
if (text.length >= 30) return 'ok';

// ✅ OK: フォールバックは安全な値のみ
if (!text?.trim()) return 'empty';
return 'thin'; // OKはAI判定からのみ
```

## 4. DB保存のフィールド完全性

### 保存と復元のフィールドを一致させる
保存時に書き込むフィールドと復元時に読み込むフィールドが**完全に一致**していることを確認する。

チェック方法:
1. 保存関数で書き込むフィールド一覧を列挙する
2. 復元関数で読み込むフィールド一覧を列挙する
3. 差分がないか比較する

### 同じデータの保存箇所が複数ある場合
同一テーブルへの保存が複数箇所（例: 初回分析、チャット応答、relatedUpdates）にある場合:
- **全箇所で同一フィールド**を保存していることを確認する
- 1箇所でも保存フィールドが欠けていると、復元後にデータ不整合が発生する

## 5. ID紐付けの健全性

### 外部キー参照はnullチェック必須
`message_id`等で別テーブルを参照する場合:
- 参照元のレコード作成が成功していること（nullでないこと）を確認する
- nullの場合はログに警告を出し、復元時にnull参照でクラッシュしないようにする

## 6. 関心の分離（UI表示 vs DB保存）【最重要】

> [!CAUTION]
> 過去にこのルール違反で**全セッションのデータが保存されないバグ**が発生した（2026-02-16）。

### DB保存をUI条件分岐の中に入れない
DB保存コードは、UI表示の条件分岐（`if (result.message)`等）の**外側**に配置する。

```javascript
// ❌ 禁止: DB保存がUI表示条件に依存
if (result.message) {
    addMsg('ai', result.message);     // UI表示
    await dbSync.saveMessage(...);     // DB保存 ← messageがfalsyなら実行されない！
    await dbSync.saveAnalysisResult(...); // DB保存 ← 同上
}

// ✅ 正解: UI表示とDB保存を分離
if (result.message) {
    addMsg('ai', result.message);  // UI表示だけ
}
// DB保存は独立して常に実行
await dbSync.saveMessage(...);
await dbSync.saveAnalysisResult(...);
```

### DB保存は常に実行
データが生成された時点で**無条件に**DB保存を実行する。
保存すべきか否かの判断は`dbSync`層（`enabled`チェック、`sessionId`チェック）に任せる。

### 変数宣言の順序
DB保存に使う変数（例: `aiMsgRecord`）は、**使用箇所より前に**宣言・代入する。
後方で宣言した変数を前方で参照することは禁止。

## 7. DB保存の成否確認

### 保存結果のログ出力（必須）
全てのDB保存呼び出しの直後に、成否をログ出力する:
```javascript
const record = await dbSync.saveMessage(...);
console.log(`[dbSync] saveMessage: id=${record?.id || 'FAILED'}`;
```

### L3検証: DB直接クエリ
DB保存の実装後は、Supabase REST APIで**DBにデータが実際に存在するか**を直接確認する:
```bash
curl -s 'https://{project}.supabase.co/rest/v1/{table}?session_id=eq.{id}' -H 'apikey: {key}'
```
コードが「存在する」だけでは保存成功の証拠にならない。
