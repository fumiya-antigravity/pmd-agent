---
description: "データ永続化・DB設計ルール。保存→復元の完全性保証、フォールバック設計、フィールド一致チェック。DB関連コード変更時は必ず参照。"
alwaysApply: true
---

# データ永続化・DB設計ルール

## 1. 永続化の基本原則

### 「保存→完全消去→復元で同じ画面が出るか」テスト（必須）
- データ永続化に関わるコードを修正した場合、必ずブラウザの完全リフレッシュ（Cmd+Shift+R）テストを行うこと
- 保存した時点と復元後の画面が**ピクセル単位で同じ**であることを目視確認する
- コードパスが存在すること ≠ 正しく動くこと。E2Eの動作確認が必須

### データフロー全体を検証する
保存側のコードだけでなく、以下の**データフロー全体**を必ずトレースすること:
1. **生成**: データが作られる箇所（AI応答パース等）
2. **state反映**: メモリ上のstate変数への格納
3. **DB保存**: Supabaseテーブルへの書き込み（全フィールドが保存されているか）
4. **DB復元**: テーブルからの読み込み（全フィールドが読まれているか）
5. **UI描画**: 復元データからの画面再構築（正しいデータソースを参照しているか）

## 2. テーブル設計ルール

### UPSERTのテーブルは最新しか保持しない
`UPSERT (ON CONFLICT)` を使うテーブルは**最新の状態しか保持しない**。
時系列の履歴が必要なユースケースがある場合は:
- 別途スナップショットテーブルを設ける（例: `aspect_snapshots`）
- または、INSERTで全バージョンを保持するテーブル設計にする

### テーブル設計前にユースケースを確認する
テーブルを設計する前に、以下を確認すること:
- そのデータを「最新だけ見たい」のか「履歴を辿りたい」のか
- ブラウザ更新後にどの画面要素が復元される必要があるか
- 複数のUI要素が同じテーブルを参照しているが、異なるタイムスタンプのデータが必要ではないか

## 3. フォールバックロジックの設計ルール

### AI判定とフォールバックを混ぜない
ステータス判定にAI判定値とフォールバック（ヒューリスティック）の2系統がある場合:
- フォールバックは**最も安全な値**を返すこと（例: "thin" or "empty"）
- フォールバックで**上位ステータス（OK等）を返してはならない**
- OK/合格の判定は、**明示的なソース（AI判定、ユーザー確認等）からのみ**許可する

```javascript
// ❌ NG: フォールバックでOK判定
if (text.length >= 30) return 'ok';

// ✅ OK: フォールバックは安全な値のみ
if (!text?.trim()) return 'empty';
return 'thin'; // OKはAI判定からのみ
```

## 4. DB保存のフィールド完全性

### 保存と復元のフィールドを一致させる
保存時に書き込むフィールドと復元時に読み込むフィールドが**完全に一致**していることを確認する。

チェック方法:
1. 保存関数で書き込むフィールド一覧を列挙する
2. 復元関数で読み込むフィールド一覧を列挙する
3. 差分がないか比較する

### 同じデータの保存箇所が複数ある場合
同一テーブルへの保存が複数箇所（例: 初回分析、チャット応答、relatedUpdates）にある場合:
- **全箇所で同一フィールド**を保存していることを確認する
- 1箇所でも保存フィールドが欠けていると、復元後にデータ不整合が発生する

## 5. ID紐付けの健全性

### 外部キー参照はnullチェック必須
`message_id`等で別テーブルを参照する場合:
- 参照元のレコード作成が成功していること（nullでないこと）を確認する
- nullの場合はログに警告を出し、復元時にnull参照でクラッシュしないようにする
